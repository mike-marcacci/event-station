{"version":3,"file":null,"sources":["../src/addListener.ts","../src/matchListener.ts","../src/removeListener.ts","../src/removeListenerFromAll.ts","../src/applyListeners.ts","../src/getAllListeners.ts","../src/matchListeners.ts","../src/hasListener.ts","../src/injection.ts","../src/Listeners.ts","../src/makeStationId.ts","../src/options.ts","../src/EventStation.ts"],"sourcesContent":["import {Listener} from './Listener';\r\nimport {Meta} from './Meta';\r\n\r\n/** Adds the given listener to the given station meta */\r\nexport function addListener(stationMeta: Meta, listener: Listener): void {\r\n\r\n    const eventName = listener.eventName;\r\n    const listenersMap = stationMeta.listenersMap;\r\n\r\n    if (!listenersMap[eventName]) {\r\n        listenersMap[eventName] = [];\r\n    }\r\n\r\n    const stationMetas = listener.stationMetas;\r\n\r\n    if (!stationMetas) {\r\n        listener.stationMetas = [stationMeta];\r\n    } else {\r\n        stationMetas.push(stationMeta);\r\n    }\r\n\r\n    listenersMap[eventName].push(listener);\r\n    stationMeta.listenerCount++;\r\n\r\n    const hearer = listener.hearer;\r\n\r\n    if (hearer) {\r\n        hearer.stationMeta.hearingCount++;\r\n    }\r\n}\r\n","import {MatchingListener} from './MatchingListener';\r\n\r\n/**\r\n * Determines whether the given listeners match by performing an approximate match\r\n * using the `matchCallback`, `matchContext`, `hearer`, and `eventName` properties.\r\n * @param exactMatch If true, an exact value match will be performed instead of an approximate match.\r\n */\r\nexport function matchListener(matchingListener: MatchingListener, attachedListener: MatchingListener, exactMatch?: boolean): boolean {\r\n\r\n    if (exactMatch === true) {\r\n        return matchingListener == attachedListener;\r\n    }\r\n\r\n    const matchCallback = matchingListener.matchCallback;\r\n\r\n    if (\r\n        matchCallback\r\n        && matchCallback !== attachedListener.matchCallback\r\n    ) {\r\n        return false\r\n    }\r\n\r\n    const matchContext = matchingListener.matchContext;\r\n\r\n    if (\r\n        matchContext !== undefined\r\n        && matchContext !== attachedListener.matchContext\r\n    ) {\r\n        return false\r\n    }\r\n\r\n    const hearer = matchingListener.hearer;\r\n\r\n    if (\r\n        hearer\r\n        && hearer !== attachedListener.hearer\r\n    ) {\r\n        return false\r\n    }\r\n\r\n    const eventName = matchingListener.eventName;\r\n\r\n    if (\r\n        eventName !== undefined\r\n        && eventName !== attachedListener.eventName\r\n    ) {\r\n        return false\r\n    }\r\n\r\n    return true;\r\n}","import {Listener} from './Listener';\r\nimport {matchListener} from './matchListener';\r\nimport {Meta} from './Meta';\r\n\r\n/**\r\n * Removes all listeners that match the given listener from the given station meta.\r\n * @param exactMatch If true, an exact value match will be performed instead of an approximate match.\r\n */\r\nexport function removeListener(stationMeta: Meta, listener: Listener, exactMatch?: boolean): void {\r\n\r\n    if (stationMeta.listenerCount < 1) return;\r\n\r\n    const listenersMap = stationMeta.listenersMap;\r\n    const eventName = listener.eventName;\r\n    const attachedListeners = listenersMap[eventName];\r\n\r\n    if (!attachedListeners) return;\r\n\r\n    let attachedListenersCount = attachedListeners.length;\r\n\r\n    if (attachedListenersCount === 1) {\r\n\r\n        if (!matchListener(listener, attachedListeners[0], exactMatch)) return;\r\n\r\n        delete listenersMap[eventName];\r\n        stationMeta.listenerCount--;\r\n        reduceHearerHearingCount(listener);\r\n        removeMetaFromStation(stationMeta, listener);\r\n\r\n        return;\r\n    }\r\n\r\n    for (let i = 0, c = attachedListenersCount; i < c; i++) {\r\n\r\n        let attachedListener = attachedListeners[i];\r\n\r\n        if (!matchListener(listener, attachedListener, exactMatch)) continue;\r\n\r\n        /* Remove the listener from the given Meta */\r\n        attachedListeners.splice(i, 1);\r\n        stationMeta.listenerCount--;\r\n        i--;\r\n        c--;\r\n\r\n        reduceHearerHearingCount(listener);\r\n        removeMetaFromStation(stationMeta, listener);\r\n    }\r\n\r\n    if (attachedListeners.length < 1) {\r\n        delete listenersMap[eventName];\r\n    }\r\n}\r\n\r\nfunction removeMetaFromStation(targetMeta: Meta, listener: Listener) {\r\n\r\n    const stationMetas = listener.stationMetas;\r\n\r\n    if (!stationMetas) return;\r\n\r\n    if (stationMetas.length === 1) {\r\n        listener.stationMetas = undefined;\r\n        return;\r\n    }\r\n\r\n    const newStationMetas: Meta[] = [];\r\n\r\n    for (let stationMeta of stationMetas) {\r\n        if (stationMeta !== targetMeta) {\r\n            newStationMetas.push(stationMeta);\r\n        }\r\n    }\r\n\r\n    if (newStationMetas.length < 1) {\r\n        /*\r\n         * This line is necessary in the rare case that\r\n         * the exact same listener object has been added to\r\n         * a station multiple times, and is then removed from\r\n         * said station.\r\n         */\r\n        listener.stationMetas = undefined;\r\n    } else {\r\n        listener.stationMetas = newStationMetas;\r\n    }\r\n}\r\n\r\nfunction reduceHearerHearingCount(listener: Listener): void {\r\n\r\n    /*\r\n     * Update the hearingCount of given listener's hearer\r\n     */\r\n    const hearer = listener.hearer;\r\n\r\n    if (hearer) {\r\n        hearer.stationMeta.hearingCount--;\r\n    }\r\n}\r\n","import {Listener} from './Listener';\r\nimport {removeListener} from './removeListener';\r\n\r\n/** Removes the given listener from all of the station meta it's attached to */\r\nexport function removeListenerFromAll(listener: Listener): void {\r\n\r\n    const stationMetas = listener.stationMetas;\r\n\r\n    if (!stationMetas) return;\r\n\r\n    for (let stationMeta of stationMetas) {\r\n        removeListener(stationMeta, listener, true);\r\n    }\r\n}\r\n","import {EventStation} from './EventStation';\r\nimport {Listener} from './Listener';\r\nimport {removeListenerFromAll} from './removeListenerFromAll';\r\n\r\n/** Applies the given listeners with the given arguments */\r\nexport function applyListeners<P extends Promise<any>>(listeners: Listener[], originStation: EventStation, enableAsync: boolean, args: ListenerArguments): P[] | void {\r\n\r\n    const argsLength = args.length;\r\n    const stationMeta = originStation.stationMeta;\r\n\r\n    stationMeta.isPropagationStopped = false;\r\n\r\n    var promises: P[] = [];\r\n    var result: any;\r\n\r\n    for (let listener of listeners) {\r\n\r\n        if (stationMeta.isPropagationStopped) {\r\n            stationMeta.isPropagationStopped = false;\r\n            return;\r\n        }\r\n\r\n        if (listener.isPaused) continue;\r\n\r\n        const callback = listener.callback;\r\n        const context = listener.context;\r\n\r\n        if (callback) {\r\n            switch (argsLength) {\r\n                case 0:\r\n                    result = callback.call(context);\r\n                    break;\r\n                case 1:\r\n                    result = callback.call(context, args[0]);\r\n                    break;\r\n                case 2:\r\n                    result = callback.call(context, args[0], args[1]);\r\n                    break;\r\n                case 3:\r\n                    result = callback.call(context, args[0], args[1], args[2]);\r\n                    break;\r\n                default:\r\n                    result = callback.apply(context, args);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        /*\r\n         * Is async enabled, and is the result a Promise-like object\r\n         */\r\n        if (\r\n            enableAsync\r\n            && result\r\n            && typeof result.then === 'function'\r\n            && typeof result.catch === 'function'\r\n        ) {\r\n            promises.push(<P>result);\r\n        }\r\n\r\n        const resolves = listener.resolves;\r\n\r\n        if (resolves) {\r\n\r\n            for (let resolve of resolves) {\r\n                resolve(listener);\r\n            }\r\n\r\n            listener.resolves = undefined;\r\n        }\r\n\r\n        const maxOccurrences = listener.maxOccurrences;\r\n        let occurrences = listener.occurrences;\r\n\r\n        if (maxOccurrences !== undefined) {\r\n\r\n            if (occurrences === undefined) {\r\n                occurrences = listener.occurrences = 1;\r\n            } else {\r\n                occurrences = ++listener.occurrences;\r\n            }\r\n\r\n            if (occurrences === maxOccurrences) {\r\n                removeListenerFromAll(listener);\r\n            }\r\n        }\r\n    }\r\n\r\n    return promises;\r\n}\r\n\r\nexport interface ListenerArguments {\r\n    [index: number]: any;\r\n    length: number;\r\n}\r\n","import {Listener} from './Listener';\r\nimport {Meta} from './Meta';\r\n\r\n/** Retrieves all listeners attached to the given Meta */\r\nexport function getAllListeners(stationMeta: Meta): Listener[] {\r\n\r\n    if (stationMeta.listenerCount < 1) return [];\r\n\r\n    const listenersMap = stationMeta.listenersMap;\r\n    var listeners: Listener[] = [];\r\n\r\n    for (let eventName in listenersMap) {\r\n        listeners = listeners.concat(listenersMap[eventName]);\r\n    }\r\n\r\n    return listeners;\r\n}\r\n","import {MatchingListener} from './MatchingListener';\r\nimport {matchListener} from './matchListener';\r\n\r\nexport function matchListeners(matchingListener: MatchingListener, attachedListeners: MatchingListener[], exactMatch?: boolean): boolean {\r\n\r\n    const count = attachedListeners.length;\r\n\r\n    if (count < 1) return false;\r\n\r\n    for (let attachedListener of attachedListeners) {\r\n\r\n        if (matchListener(matchingListener, attachedListener, exactMatch)) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n","import {getAllListeners} from './getAllListeners';\r\nimport {Listener} from './Listener';\r\nimport {MatchingListener} from './MatchingListener';\r\nimport {matchListeners} from './matchListeners';\r\nimport {Meta} from './Meta';\r\n\r\n/**\r\n * Determines whether the given listener is attached to the given station meta.\r\n * @param exactMatch If true, an exact value match will be performed instead of an approximate match.\r\n */\r\nexport function hasListener(stationMeta: Meta, listener: MatchingListener, exactMatch?: boolean): boolean {\r\n\r\n    const listenersMap = stationMeta.listenersMap;\r\n    const eventName = listener.eventName;\r\n    var attachedListeners: Listener[];\r\n\r\n    if (eventName === undefined) {\r\n\r\n        attachedListeners = getAllListeners(stationMeta);\r\n\r\n    } else {\r\n\r\n        attachedListeners = listenersMap[eventName];\r\n\r\n        if (!attachedListeners) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return matchListeners(listener, attachedListeners, exactMatch);\r\n}\r\n","declare const global: any;\r\ndeclare const window: any;\r\n\r\nconst glob = typeof window !== 'undefined' ? window : global;\r\nconst $DefaultPromise: typeof Promise = glob.Promise;\r\n\r\nexport namespace deps {\r\n    /**\r\n     * A reference to the injected Rx namespace.\r\n     * @see inject()\r\n     */\r\n    export let $RxObservable: Rx.ObservableStatic | void = undefined;\r\n\r\n    /**\r\n     * A reference to the Promise object, or an injected Promise-like object.\r\n     * @see inject()\r\n     */\r\n    export let $Promise: typeof Promise | void = $DefaultPromise;\r\n};\r\n\r\n/**\r\n * Injects or overrides an optional dependency.\r\n *\r\n * Use this method to provide EventStation with the `rx` namespace.\r\n * Doing so enables the use of `Listeners.prototype.toObservable()`.\r\n *\r\n *     inject('rx', rx)\r\n *\r\n * EventStation will use the native Promise object by default.\r\n * If a Promise object isn't globally available, one can be\r\n * injected to be used in its place.\r\n *\r\n *     inject('Promise', YourPromiseObject)\r\n *\r\n * For example, Bluebird can be injected to override the Promise used\r\n * within EventStation instances.\r\n */\r\nexport function inject(name: 'rx', rx: any): void;\r\nexport function inject(name: 'Promise', Promise: any): void;\r\nexport function inject(name: string, obj: any): void;\r\nexport function inject(name: string, obj: any): void {\r\n\r\n    switch (name) {\r\n\r\n        case 'rx':\r\n            deps.$RxObservable = obj ? obj.Observable : obj;\r\n            break;\r\n\r\n        case 'Promise':\r\n            deps.$Promise = obj;\r\n            break;\r\n\r\n        default:\r\n            throw new Error('Invalid name');\r\n    }\r\n}\r\n\r\n/** Reset injected dependencies */\r\nexport function reset(): void {\r\n    deps.$RxObservable = undefined;\r\n    deps.$Promise = $DefaultPromise;\r\n}\r\n","import {addListener} from './addListener';\r\nimport {deps} from './injection';\r\nimport {Emitter} from './Emitter';\r\nimport {EventStation} from './EventStation';\r\nimport {hasListener} from './hasListener';\r\nimport {Listener} from './Listener';\r\nimport {MatchingListener} from './MatchingListener';\r\nimport {matchListeners} from './matchListeners';\r\nimport {Meta} from './Meta';\r\nimport {removeListener} from './removeListener';\r\nimport {removeListenerFromAll} from './removeListenerFromAll';\r\n\r\n/**\r\n * A class for operations targeting a collection of listeners\r\n */\r\nexport class Listeners {\r\n\r\n    /** @returns The number of listeners in the collection */\r\n    public get count(): number {\r\n        return this.listeners.length;\r\n    }\r\n\r\n    /** The station which the listeners originate from */\r\n    private originStation: Emitter;\r\n\r\n    /** An array of listeners */\r\n    private listeners: Listener[];\r\n\r\n    constructor(originStation: Emitter, listeners: Listener[]) {\r\n        this.originStation = originStation;\r\n        this.listeners = listeners;\r\n    }\r\n\r\n    /**\r\n     * Sets each listener's maximum occurrence\r\n     */\r\n    public occur(maxOccurrences: number): Listeners {\r\n\r\n        if (maxOccurrences < 1) {\r\n            throw new Error(\"The maximum occurrences must be greater than or equal to one.\");\r\n        }\r\n\r\n        const listeners = this.listeners;\r\n\r\n        for (let listener of listeners) {\r\n            listener.maxOccurrences = maxOccurrences;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets each listener's callback function\r\n     */\r\n    public calling(callback: Function): Listeners {\r\n\r\n        const listeners = this.listeners;\r\n\r\n        for (let listener of listeners) {\r\n            listener.callback = callback;\r\n            listener.matchCallback = callback;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets each listener's callback function, and maximum occurrence to one(1)\r\n     */\r\n    public once(callback: Function): Listeners {\r\n\r\n        return this.calling(callback).occur(1);\r\n    }\r\n\r\n    /**\r\n     * Removes the listeners from all stations\r\n     */\r\n    public off(): Listeners {\r\n\r\n        const listeners = this.listeners;\r\n\r\n        for (let listener of listeners) {\r\n            removeListenerFromAll(listener);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sets the context of each listener\r\n     */\r\n    public using(context: any): Listeners {\r\n\r\n        const listeners = this.listeners;\r\n\r\n        for (let listener of listeners) {\r\n            listener.context = context;\r\n            listener.matchContext = context;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Adds each listener to the given station\r\n     */\r\n    public addTo(station: EventStation): Listeners {\r\n\r\n        const listeners = this.listeners;\r\n        const stationMeta = station.stationMeta;\r\n\r\n        for (let listener of listeners) {\r\n\r\n            const crossOrigin = listener.crossOrigin;\r\n\r\n            if (crossOrigin && crossOrigin !== station) {\r\n                throw new Error(\"Cross-emitter listeners can only be attached to their origin station.\");\r\n            }\r\n\r\n            addListener(stationMeta, listener);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Removes each listener from the given station\r\n     */\r\n    public removeFrom(station: EventStation): Listeners {\r\n\r\n        const listeners = this.listeners;\r\n        const stationMeta = station.stationMeta;\r\n\r\n        for (let listener of listeners) {\r\n            removeListener(stationMeta, listener, true);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Moves the listeners to another station.\r\n     * This method changes the origin station.\r\n     */\r\n    public moveTo(station: Emitter): Listeners {\r\n\r\n        this.removeFrom(this.originStation);\r\n        this.originStation = station;\r\n        this.addTo(station);\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Determines whether any listener in the collection matches the given listener.\r\n     * @param exactMatch If true, an exact value match will be performed instead of an approximate match.\r\n     */\r\n    public has(matchingListener: MatchingListener, exactMatch?: boolean): boolean {\r\n        return matchListeners(matchingListener, this.listeners, exactMatch);\r\n    }\r\n\r\n    /**\r\n     * Adds the listeners to the origin station\r\n     */\r\n    public attach(): Listeners {\r\n        return this.addTo(this.originStation);\r\n    }\r\n\r\n    /**\r\n     * Removes the listeners from the origin station\r\n     */\r\n    public detach(): Listeners {\r\n        return this.removeFrom(this.originStation);\r\n    }\r\n\r\n    /**\r\n     * Determines whether any of the listeners are attached to the given station.\r\n     * If no station is given, the method determines whether any of the listeners\r\n     * are attached to *any* station.\r\n     */\r\n    public isAttachedTo(station?: EventStation): boolean {\r\n\r\n        if (!station) {\r\n            return isListenersAttached(this.listeners);\r\n        }\r\n\r\n        return hasListeners(station.stationMeta, this.listeners, true);\r\n    }\r\n\r\n    /**\r\n     * Determines whether any of the listeners are attached to the origin station\r\n     */\r\n    public isAttached(): boolean {\r\n        return this.isAttachedTo(this.originStation);\r\n    }\r\n\r\n    /**\r\n     * Pauses each listener\r\n     */\r\n    public pause(): Listeners {\r\n\r\n        const listeners = this.listeners;\r\n\r\n        for (let listener of listeners) {\r\n            listener.isPaused = true;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Un-pauses each listener\r\n     */\r\n    public resume(): Listeners {\r\n\r\n        const listeners = this.listeners;\r\n\r\n        for (let listener of listeners) {\r\n            listener.isPaused = false;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Determines whether any of listeners are paused\r\n     */\r\n    public isPaused(): boolean {\r\n\r\n        const listeners = this.listeners;\r\n\r\n        for (let listener of listeners) {\r\n            if (listener.isPaused) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @returns An iterable object (array) containing a promise\r\n     * for each listener that resolves when said listener is applied.\r\n     * This method is dependant on `Promise`.\r\n     * @see inject()\r\n     */\r\n    public toPromises(): Array<Promise<Listener>> {\r\n\r\n        const promises: Array<Promise<Listener>> = [];\r\n        const listeners = this.listeners;\r\n\r\n        for (let i = 0, c = listeners.length; i < c; i++) {\r\n            let listener = listeners[i];\r\n\r\n            promises[i] = makePromise(listener);\r\n        }\r\n\r\n        return promises;\r\n    }\r\n\r\n    /**\r\n     * @returns A promise that resolves when all of the listeners\r\n     * have been applied at least once.\r\n     * This method is dependant on `Promise`.\r\n     * @see inject()\r\n     */\r\n    public all(): Promise<Listener[]> {\r\n\r\n        return deps.$Promise.all<Listener>(this.toPromises());\r\n    }\r\n\r\n    /**\r\n     * @returns A promise that resolves when one of the listeners is applied.\r\n     * This method is dependant on `Promise`.\r\n     * @see inject()\r\n     */\r\n    public race(): Promise<Listener> {\r\n\r\n        return deps.$Promise.race<Listener>(this.toPromises());\r\n    }\r\n\r\n    /**\r\n     * Un-pauses each listener, and resets each listener's occurrence count\r\n     */\r\n    public reset(): Listeners {\r\n\r\n        const listeners = this.listeners;\r\n\r\n        for (let listener of listeners) {\r\n            listener.occurrences = undefined;\r\n            listener.isPaused = undefined;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Similar to Array.prototype.forEach() */\r\n    public forEach(func: ForEachCallback): Listeners {\r\n\r\n        const listeners = this.listeners;\r\n\r\n        for (let i = 0, c = listeners.length; i < c; i++) {\r\n            let listener = listeners[i];\r\n\r\n            func(listener, i, listeners);\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    /** Retrieves a listener located at the given index */\r\n    public get(index: number): Listener {\r\n        return this.listeners[index];\r\n    }\r\n\r\n    /** Retrieves the index of the given listener */\r\n    public index(listener: Listener): number | void {\r\n\r\n        const listeners = this.listeners;\r\n\r\n        for (let i = 0, c = listeners.length; i < c; i++) {\r\n            if (listener === listeners[i]) return i;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns A new `Listeners` object containing a clone of each Listener\r\n     */\r\n    public clone(): Listeners {\r\n        const clonedListeners = this.listeners.map(cloneListener);\r\n\r\n        return new Listeners(this.originStation, clonedListeners);\r\n    }\r\n}\r\n\r\n/** Creates a `Promise` and adds its `resolve` function to the listener's `resolves` array */\r\nfunction makePromise(listener: Listener): Promise<Listener> {\r\n\r\n    if (!deps.$Promise) {\r\n        throw new Error('No promises implementation available.');\r\n    }\r\n\r\n    return new deps.$Promise<Listener>(function (resolve) {\r\n\r\n        if (!listener.resolves) {\r\n            listener.resolves = [resolve];\r\n        } else {\r\n            listener.resolves.push(resolve);\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Clones the given listener\r\n * Does not clone the listener's `stationMetas` or `resolves` properties\r\n * @throws an `Error` if the listener is a cross-emitter listener\r\n */\r\nfunction cloneListener(listener: Listener): Listener {\r\n\r\n    if (listener.hearer) {\r\n        throw new Error(\"Cross-emitter listeners can not be cloned.\");\r\n    }\r\n\r\n    return {\r\n        eventName: listener.eventName,\r\n        callback: listener.callback,\r\n        context: listener.context,\r\n        matchCallback: listener.matchCallback,\r\n        matchContext: listener.matchContext,\r\n        isPaused: listener.isPaused,\r\n        occurrences: listener.occurrences,\r\n        maxOccurrences: listener.maxOccurrences,\r\n    };\r\n}\r\n\r\n/** Determines whether the given listeners are attached to any stations */\r\nexport function isListenersAttached(listeners: Listener[]) {\r\n    for (let listener of listeners) {\r\n        if (isListenerAttached(listener)) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/** Determines whether the given listener is attached to any stations */\r\nexport function isListenerAttached(listener: Listener): boolean {\r\n    return listener.stationMetas !== undefined;\r\n}\r\n\r\n/**\r\n * Determines whether the given station meta has listeners that match the given listeners\r\n * @param exactMatch If true, an exact value match will be performed instead of an approximate match.\r\n */\r\nfunction hasListeners(stationMeta: Meta, listeners: Listener[], exactMatch?: boolean) {\r\n    for (let listener of listeners) {\r\n        if (hasListener(stationMeta, listener, exactMatch)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nexport interface ForEachCallback {\r\n    (listener: Listener, index: number, listeners: Listener[]): any;\r\n}\r\n","/** Iterator for generating unique station IDs */\r\nvar stationIdIterator: number = 0;\r\n\r\n/** Generates a unique ID for EventStation instances */\r\nexport function makeStationId(): string {\r\n    return String(++stationIdIterator);\r\n}\r\n","/** Container for global configuration options */\r\nexport const defaultOptions = {\r\n    delimiter: ' ',\r\n    emitAllEvent: true,\r\n    enableDelimiter: true,\r\n    enableRegExp: false,\r\n    regExpMarker: '%',\r\n};\r\n\r\n/** Container for global configuration options */\r\nexport const globalOptions = mergeOptions({}, defaultOptions);\r\n\r\n/** Resets the global configuration to defaults */\r\nexport function reset(): void {\r\n    mergeOptions(globalOptions, defaultOptions)\r\n}\r\n\r\n/** Modifies the default global configuration */\r\nexport function config(opts: Options): void {\r\n    let testOptions = mergeOptions({}, globalOptions, opts);\r\n\r\n    assertOptions(testOptions);\r\n\r\n    mergeOptions(globalOptions, opts);\r\n}\r\n\r\n/**\r\n * Validates the given options\r\n * @throws Error\r\n */\r\nexport function assertOptions<T extends typeof defaultOptions>(opts: T) {\r\n    if (opts.delimiter === '') {\r\n        throw new Error(\"Invalid option: Delimiters can't be empty strings.\");\r\n    }\r\n\r\n    if (opts.regExpMarker === '') {\r\n        throw new Error(\"Invalid option: RegExp markers can't be empty strings.\");\r\n    }\r\n\r\n    if (opts.regExpMarker && opts.delimiter && opts.regExpMarker.indexOf(opts.delimiter) >= 0) {\r\n        throw new Error(\"Invalid option: RegExp markers can't contain the delimiter string.\");\r\n    }\r\n}\r\n\r\nexport function mergeOptions<T extends typeof defaultOptions>(target: any, ...sources: any[]): T {\r\n\r\n    for (var i = 1; i < arguments.length; i++) {\r\n        var source = arguments[i];\r\n\r\n        for (let option in defaultOptions) {\r\n            let isValidOption = defaultOptions.hasOwnProperty(option);\r\n            let value = source[option];\r\n\r\n            if (isValidOption && value != null) {\r\n                target[option] = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    return target;\r\n}\r\n\r\n/**\r\n* See the [configuration section](http://morrisallison.github.io/event-station/usage.html#configuration)\r\n* of the usage documentation for general usage.\r\n*/\r\nexport interface Options {\r\n    /**\r\n     * The character used to delimit event names in a string.\r\n     * `\" \"` (space) by default.\r\n     */\r\n    delimiter?: string;\r\n    /**\r\n     * Determines whether a station emits an `\"all\"` event for every event that is emitted.\r\n     * `true` by default.\r\n     */\r\n    emitAllEvent?: boolean;\r\n    /**\r\n     * Determines whether a station can use delimited event names.\r\n     * `true` by default.\r\n     */\r\n    enableDelimiter?: boolean;\r\n    /**\r\n     * Determines whether a station can use regular expression listeners.\r\n     * `false` by default.\r\n     */\r\n    enableRegExp?: boolean;\r\n    /**\r\n     * A string used to mark regular expression listeners.\r\n     * `\"%\"` by default.\r\n     */\r\n    regExpMarker?: string;\r\n    [key: string]: string | boolean | void;\r\n    [key: number]: void;\r\n}","import {addListener} from './addListener';\r\nimport {applyListeners} from './applyListeners';\r\nimport {Emitter} from './Emitter';\r\nimport {getAllListeners} from './getAllListeners';\r\nimport {hasListener} from './hasListener';\r\nimport {Listener} from './Listener';\r\nimport {Listeners} from './Listeners';\r\nimport {ListenersMap} from './ListenersMap';\r\nimport {makeStationId} from './makeStationId';\r\nimport {matchListener} from './matchListener';\r\nimport {Meta} from './Meta';\r\nimport {removeListener} from './removeListener';\r\nimport {StationMap} from './StationMap';\r\nimport * as injection from './injection';\r\nimport * as options from './options';\r\n\r\n/**\r\n * Event emitter class and namespace\r\n */\r\nexport class EventStation {\r\n\r\n    /** Container for the station's context */\r\n    public stationMeta: Meta;\r\n\r\n    constructor(options?: options.Options) {\r\n        EventStation.init(this, options);\r\n    }\r\n\r\n    /** An ID unique to all stations */\r\n    public get stationId(): string {\r\n        return this.stationMeta.stationId;\r\n    }\r\n\r\n    /** Number of listeners attached to the station */\r\n    public get listenerCount(): number {\r\n        return this.stationMeta.listenerCount;\r\n    }\r\n\r\n    /**\r\n     * Number of listeners attached to other stations by the station.\r\n     * This value is increased by using `hear()` and `hearOnce()`.\r\n     */\r\n    public get hearingCount(): number {\r\n        return this.stationMeta.hearingCount;\r\n    }\r\n\r\n    /** Array of event names which have listeners on the station */\r\n    public get listenerEventNames(): string[] {\r\n        return Object.getOwnPropertyNames(this.stationMeta.listenersMap);\r\n    }\r\n\r\n    /**\r\n     * Creates and attaches listeners to the station\r\n     */\r\n    public on(listenerMap: CallbackMap, context?: any): Listeners;\r\n    public on(eventNames: string[], callback?: Function, context?: any): Listeners;\r\n    public on(eventName: string, callback?: Function, context?: any): Listeners;\r\n    public on(q: any, r?: any, s?: any): Listeners {\r\n\r\n        const stationMeta = this.stationMeta;\r\n        const listeners = makeListeners(this, false, q, r, s);\r\n\r\n        for (let listener of listeners) {\r\n            addListener(stationMeta, listener);\r\n        }\r\n\r\n        return new Listeners(this, listeners);\r\n    }\r\n\r\n    /**\r\n     * Creates and attaches listeners to the station that are applied once and removed\r\n     */\r\n    public once(listenerMap: CallbackMap, context?: any): Listeners;\r\n    public once(eventNames: string[], callback?: Function, context?: any): Listeners;\r\n    public once(eventName: string, callback?: Function, context?: any): Listeners;\r\n    public once(q: any, r?: any, s?: any): Listeners {\r\n\r\n        return this.on(q, r, s).occur(1);\r\n    }\r\n\r\n    /**\r\n     * Removes listeners from the station that match the given arguments.\r\n     * If no arguments are given, all listeners will be removed;\r\n     * including listeners that were attached via `hear()` or `hearOnce()`.\r\n     */\r\n    public off(): void;\r\n    public off(listenerMap: CallbackMap, context?: any): void;\r\n    public off(eventNames: string[], callback?: Function, context?: any): void;\r\n    public off(eventName: string, callback?: Function, context?: any): void;\r\n    public off(q?: any, r?: any, s?: any): void {\r\n\r\n        const stationMeta = this.stationMeta;\r\n\r\n        if (stationMeta.listenerCount < 1) return;\r\n\r\n        // If no listener targets were given\r\n        if (q === undefined) {\r\n            removeAllListeners(stationMeta);\r\n            return;\r\n        }\r\n\r\n        if (\r\n            r === undefined\r\n            && s === undefined\r\n            && typeof q === 'string'\r\n            && (!stationMeta.enableDelimiter || q.indexOf(stationMeta.delimiter) < 0)\r\n        ) {\r\n            removeListeners(q, stationMeta);\r\n            return;\r\n        }\r\n\r\n        const listeners = makeListeners(this, true, q, r, s);\r\n\r\n        for (let listener of listeners) {\r\n            removeListener(stationMeta, listener);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates and attaches listeners to another station.\r\n     * Listeners attached using this method can be removed specifically by using `disregard()`.\r\n     */\r\n    public hear(station: Emitter, listenerMap: CallbackMap, context?: any): Listeners;\r\n    public hear(station: Emitter, eventNames: string[], callback?: Function, context?: any): Listeners;\r\n    public hear(station: Emitter, eventName: string, callback?: Function, context?: any): Listeners;\r\n    public hear(station: Emitter, q: any, r?: any, s?: any): Listeners {\r\n\r\n        const heardStations = this.stationMeta.heardStations;\r\n        const listeners = makeListeners(this, false, q, r, s);\r\n        const targetStationMeta = station.stationMeta;\r\n\r\n        for (let listener of listeners) {\r\n            listener.hearer = this;\r\n            listener.crossOrigin = station;\r\n            addListener(targetStationMeta, listener);\r\n            heardStations[station.stationId] = station;\r\n        }\r\n\r\n        return new Listeners(station, listeners);\r\n    }\r\n\r\n    /**\r\n     * Attaches listeners to another station that are applied once and removed\r\n     * Listeners attached using this method can be removed specifically by using `disregard()`.\r\n     */\r\n    public hearOnce(station: Emitter, listenerMap: CallbackMap, context?: any): Listeners;\r\n    public hearOnce(station: Emitter, eventNames: string[], callback?: Function, context?: any): Listeners;\r\n    public hearOnce(station: Emitter, eventName: string, callback?: Function, context?: any): Listeners;\r\n    public hearOnce(station: Emitter, q: any, r?: any, s?: any): Listeners {\r\n\r\n        return this.hear(station, q, r, s).occur(1);\r\n    }\r\n\r\n    /**\r\n     * Removes listeners from other stations that were attached by the station\r\n     * via `hear()` and `hearOnce()`. If no arguments are given, all listeners\r\n     * that were attached to other stations are removed.\r\n     */\r\n    public disregard(): void;\r\n    public disregard(target: EventStation | EventStation[]): void;\r\n    public disregard(target: EventStation | EventStation[], listenerMap: CallbackMap, context?: any): void;\r\n    public disregard(target: EventStation | EventStation[], eventNames: string[], callback?: Function, context?: any): void;\r\n    public disregard(target: EventStation | EventStation[], eventName: string, callback?: Function, context?: any): void;\r\n    public disregard(target?: any, q?: any, r?: any, s?: any): void {\r\n\r\n        const stationMeta = this.stationMeta;\r\n\r\n        if (stationMeta.hearingCount < 1) return;\r\n\r\n        var isRemovingAll = false;\r\n        var listeners: Listener[] = [];\r\n\r\n        // If no listener targets were given\r\n        if (q === undefined) {\r\n            isRemovingAll = true;\r\n        } else {\r\n            listeners = makeListeners(this, true, q, r, s);\r\n        }\r\n\r\n        const stations = getTargetedStations(stationMeta, target);\r\n\r\n        for (let x = 0, y = stations.length; x < y; x++) {\r\n\r\n            let station = stations[x];\r\n            let targetStationMeta = station.stationMeta;\r\n\r\n            if (isRemovingAll) {\r\n                q = station.listenerEventNames;\r\n                listeners = makeListeners(this, true, q, r, s);\r\n            }\r\n\r\n            for (let listener of listeners) {\r\n                listener.hearer = this;\r\n                removeListener(targetStationMeta, listener);\r\n            }\r\n        }\r\n\r\n        if (isRemovingAll) {\r\n            stationMeta.heardStations = Object.create(null);\r\n        } else {\r\n            cleanHeardStations(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determines whether the station has attached listeners that match the\r\n     * given arguments. If no arguments are given, the method determines\r\n     * whether the station has any attached listeners.\r\n     */\r\n    public isHeard(): boolean;\r\n    public isHeard(listenerMap: CallbackMap, context?: any): boolean;\r\n    public isHeard(eventNames: string[], callback?: Function, context?: any): boolean;\r\n    public isHeard(eventName: string, callback?: Function, context?: any): boolean;\r\n    public isHeard(q?: any, r?: any, s?: any): boolean {\r\n\r\n        const stationMeta = this.stationMeta;\r\n        const listenerCount = stationMeta.listenerCount;\r\n\r\n        if (listenerCount < 1) return false;\r\n\r\n        if (arguments.length < 1) {\r\n            // Determine if any listeners are attached\r\n            return listenerCount > 0;\r\n        }\r\n\r\n        const listeners = makeListeners(this, true, q, r, s);\r\n\r\n        for (let listener of listeners) {\r\n            if (hasListener(stationMeta, listener)) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Determines whether other stations have listeners matching the given\r\n     * arguments that were attached by the station via `hear()` and `hearOnce()`.\r\n     * If no arguments are given, the method determines whether other stations\r\n     * have any listeners attached by the station via `hear()` and `hearOnce()`.\r\n     */\r\n    public isHearing(): boolean;\r\n    public isHearing(target: EventStation | EventStation[]): boolean;\r\n    public isHearing(target: EventStation | EventStation[], listenerMap: CallbackMap): boolean;\r\n    public isHearing(target: EventStation | EventStation[], eventNames: string[], callback?: Function): boolean;\r\n    public isHearing(target: EventStation | EventStation[], eventName: string, callback?: Function): boolean;\r\n    public isHearing(target?: any, q?: any, r?: any, s?: any): boolean {\r\n\r\n        const stationMeta = this.stationMeta;\r\n\r\n        if (stationMeta.hearingCount < 1) return false;\r\n\r\n        const stations = getTargetedStations(stationMeta, target);\r\n        var matchAllListeners: boolean = false;\r\n\r\n        var listeners: Listener[] = [];\r\n\r\n        // If no listener targets were given\r\n        if (q) {\r\n            listeners = makeListeners(this, true, q, r, s);\r\n        } else {\r\n            matchAllListeners = true;\r\n        }\r\n\r\n        for (let x = 0, y = stations.length; x < y; x++) {\r\n\r\n            let station = stations[x];\r\n            let targetStationMeta = station.stationMeta;\r\n\r\n            if (matchAllListeners) {\r\n                q = station.listenerEventNames;\r\n                listeners = makeListeners(this, true, q, r, s);\r\n            }\r\n\r\n            for (let listener of listeners) {\r\n                listener.hearer = this;\r\n\r\n                if (hasListener(targetStationMeta, listener)) return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Emits events on the station.\r\n     * Parameters after the first are passed to each listener's callback function.\r\n     */\r\n    public emit(eventNames: string[], ...args: any[]): void;\r\n    public emit(eventName: string, ...args: any[]): void;\r\n    public emit(input: any, ...args: any[]): void {\r\n\r\n        const stationMeta = this.stationMeta;\r\n\r\n        if (stationMeta.listenerCount < 1) return;\r\n\r\n        const eventNames = parseEventNames(input, stationMeta);\r\n\r\n        for (let eventName of eventNames) {\r\n            emitEvent(eventName, this, false, args);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Emits events on the station, and then completes asynchronously.\r\n     * Parameters after the first are passed to each listener's callback function.\r\n     * @returns A `Promise` that resolves after all of the return listener promises resolve.\r\n     */\r\n    public emitAsync<R extends any>(eventNames: string[], ...args: any[]): Promise<R[]>;\r\n    public emitAsync<R extends any>(eventName: string, ...args: any[]): Promise<R[]>;\r\n    public emitAsync<R extends any>(input: any, ...args: any[]): Promise<R[]> {\r\n\r\n        if (!injection.deps.$Promise) {\r\n            throw new Error('No promises implementation available.');\r\n        }\r\n\r\n        const stationMeta = this.stationMeta;\r\n\r\n        if (stationMeta.listenerCount < 1) {\r\n            return injection.deps.$Promise.resolve([]);\r\n        }\r\n\r\n        const eventNames = parseEventNames(input, stationMeta);\r\n\r\n        var promises: Promise<R>[] = [];\r\n\r\n        for (let eventName of eventNames) {\r\n            promises = promises.concat(\r\n                emitEvent<Promise<R>>(eventName, this, true, args)\r\n            );\r\n        }\r\n\r\n        if (promises.length > 0) {\r\n            return injection.deps.$Promise.all<R>(promises);\r\n        } else {\r\n            return injection.deps.$Promise.resolve([]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates listeners without attaching them to the station\r\n     */\r\n    public makeListeners(listenerMap: CallbackMap, context?: any): Listeners;\r\n    public makeListeners(eventNames: string[], callback?: Function, context?: any): Listeners;\r\n    public makeListeners(eventName: string, callback?: Function, context?: any): Listeners;\r\n    public makeListeners(q: any, r?: any, s?: any): Listeners {\r\n\r\n        const listeners = makeListeners(this, false, q, r, s);\r\n\r\n        return new Listeners(this, listeners);\r\n    }\r\n\r\n    /**\r\n     * @returns Listeners from the station that match the given arguments.\r\n     * If no arguments are given, all listeners will be returned;\r\n     * including listeners that were attached via `hear()` or `hearOnce()`.\r\n     */\r\n    public getListeners(): Listeners;\r\n    public getListeners(listenerMap: CallbackMap, context?: any): Listeners;\r\n    public getListeners(eventNames: string[], callback?: Function, context?: any): Listeners;\r\n    public getListeners(eventName: string, callback?: Function, context?: any): Listeners;\r\n    public getListeners(q?: any, r?: any, s?: any): Listeners | void {\r\n\r\n        const attachedListeners = getAllListeners(this.stationMeta);\r\n\r\n        if (attachedListeners.length < 1) {\r\n            return undefined;\r\n        }\r\n        if (arguments.length < 1) {\r\n            return new Listeners(this, attachedListeners);\r\n        }\r\n\r\n        const matchingListeners = makeListeners(this, true, q, r, s);\r\n        const listeners: Listener[] = [];\r\n\r\n        for (let attachedListener of attachedListeners) {\r\n            for (let matchingListener of matchingListeners) {\r\n                if (matchListener(matchingListener, attachedListener)) {\r\n                    listeners.push(attachedListener);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // No matching listeners were found\r\n        if (listeners.length < 1) return undefined;\r\n\r\n        return new Listeners(this, listeners);\r\n    }\r\n\r\n    /**\r\n     * @returns A new Rx.Observable object from the station\r\n     * This method is dependant on `rx`.\r\n     * @see inject()\r\n     */\r\n    public toObservable<T>(eventNames: string[], context?: any, selector?: (args: any[]) => T): Rx.Observable<T>;\r\n    public toObservable<T>(eventName: string, context?: any, selector?: (args: any[]) => T): Rx.Observable<T>;\r\n    public toObservable<T>(q: any, s?: any, selector?: (args: any[]) => T): Rx.Observable<T> {\r\n\r\n        if (!injection.deps.$RxObservable) {\r\n            throw new Error('Rx has not been injected. See documentation for details.');\r\n        }\r\n\r\n        return injection.deps.$RxObservable.fromEventPattern<T>((r) => {\r\n            this.on(q, r, s);\r\n        }, (r) => {\r\n            this.off(q, r, s);\r\n        }, selector);\r\n    }\r\n\r\n    /**\r\n     * Stops the propagation of an emitted event. When called, this method effectively does\r\n     * nothing if an event is not being emitted at the time.\r\n     */\r\n    public stopPropagation(): void {\r\n        this.stationMeta.isPropagationStopped = true;\r\n    }\r\n\r\n    /**\r\n     * Adds the given listener to the station\r\n     */\r\n    public addListener(listener: Listener): void {\r\n        addListener(this.stationMeta, listener);\r\n    }\r\n\r\n    /**\r\n    * Removes all listeners that match the given listener from the station\r\n    * @param exactMatch If true, an exact value match will be performed instead of an approximate match.\r\n    */\r\n    public removeListener(listener: Listener, exactMatch?: boolean): void {\r\n        removeListener(this.stationMeta, listener, exactMatch);\r\n    }\r\n\r\n    /**\r\n    * Determines whether any listener attached to the station matches the given listener.\r\n    * @param exactMatch If true, an exact value match will be performed instead of an approximate match.\r\n    */\r\n    public hasListener(listener: Listener, exactMatch?: boolean): boolean {\r\n        return hasListener(this.stationMeta, listener, exactMatch);\r\n    }\r\n\r\n    /** Initializes the given object */\r\n    public static init(obj: any, options?: options.Options): typeof EventStation {\r\n        obj.stationMeta = makeStationMeta(options);\r\n\r\n        return EventStation;\r\n    }\r\n\r\n    public static inject(name: string, obj: any): typeof EventStation {\r\n        injection.inject(name, obj);\r\n\r\n        return EventStation;\r\n    }\r\n\r\n    /** Modifies the global configuration */\r\n    public static config(opts: options.Options): typeof EventStation {\r\n        options.config(opts);\r\n\r\n        return EventStation;\r\n    }\r\n\r\n    /** Resets the global configuration and injected dependencies */\r\n    public static reset(): typeof EventStation {\r\n        options.reset();\r\n        injection.reset();\r\n\r\n        return EventStation;\r\n    }\r\n\r\n    /**\r\n     * Extends an object with EventStation's public members\r\n     */\r\n    public static extend(obj: any): any {\r\n\r\n        const proto = EventStation.prototype;\r\n\r\n        for (let propertyName in proto) {\r\n\r\n            const descriptor = Object.getOwnPropertyDescriptor(proto, propertyName);\r\n            const newDescriptor: PropertyDescriptor = { configurable: true };\r\n\r\n            if (descriptor.get !== undefined) {\r\n                newDescriptor.get = descriptor.get;\r\n            } else {\r\n                newDescriptor.value = descriptor.value;\r\n            }\r\n\r\n            Object.defineProperty(obj, propertyName, newDescriptor);\r\n        }\r\n\r\n        return obj;\r\n    }\r\n}\r\n\r\nfunction parseEventNames(eventNames: string[], options: Meta): string[];\r\nfunction parseEventNames(eventName: string, options: Meta): string[];\r\nfunction parseEventNames(input: any, options: Meta): string[] {\r\n\r\n    var names: string[];\r\n\r\n    if (typeof input === 'string') {\r\n\r\n        const delimiter = options.delimiter;\r\n\r\n        if (options.enableDelimiter && delimiter) {\r\n\r\n            names = input.split(delimiter);\r\n\r\n        } else {\r\n\r\n            names = [input];\r\n        }\r\n\r\n    } else if (Array.isArray(input)) {\r\n\r\n        names = input;\r\n\r\n    } else {\r\n\r\n        throw new Error(\"Invalid first argument\");\r\n    }\r\n\r\n    return names;\r\n}\r\n\r\n/** Creates a new station meta object from the given configuration options */\r\nfunction makeStationMeta(config: options.Options = {}): Meta {\r\n    const state = {\r\n        heardStations: Object.create(null),\r\n        hearingCount: 0,\r\n        isPropagationStopped: false,\r\n        listenerCount: 0,\r\n        listenersMap: Object.create(null),\r\n        stationId: makeStationId(),\r\n    };\r\n\r\n    const meta = options.mergeOptions<Meta>(state, options.globalOptions, config);\r\n\r\n    options.assertOptions(meta);\r\n\r\n    return meta;\r\n}\r\n\r\n/**\r\n * Makes an array of listeners from the given parameters\r\n * This function normalizes the four ways to make listeners.\r\n */\r\nfunction makeListeners(originStation: Emitter, isMatching: boolean, listenerMap: CallbackMap, context?: EventStation): Listener[];\r\nfunction makeListeners(originStation: Emitter, isMatching: boolean, eventNames: string[], callback?: Function, context?: EventStation): Listener[];\r\nfunction makeListeners(originStation: Emitter, isMatching: boolean, eventName: string, callback?: Function, context?: EventStation): Listener[];\r\nfunction makeListeners(originStation: Emitter, isMatching: boolean, q: any, r?: any, s?: any): Listener[] {\r\n\r\n    if (typeof q === 'string') {\r\n\r\n        const stationMeta = originStation.stationMeta;\r\n        const enableDelimiter = stationMeta.enableDelimiter;\r\n        const delimiter = stationMeta.delimiter;\r\n\r\n        if (enableDelimiter && q.indexOf(delimiter) >= 0) {\r\n            q = (<string>q).split(delimiter);\r\n            return makeListenersFromArray(originStation, isMatching, q, r, s);\r\n        }\r\n\r\n        return [{\r\n            eventName: q,\r\n            callback: r,\r\n            context: !isMatching && s === undefined ? originStation : s,\r\n            matchCallback: r,\r\n            matchContext: s,\r\n        }];\r\n    }\r\n\r\n    if (Array.isArray(q)) {\r\n        return makeListenersFromArray(originStation, isMatching, q, r, s);\r\n    }\r\n\r\n    if (typeof q === 'object') {\r\n        return makeListenersFromMap(originStation, isMatching, q, r);\r\n    }\r\n\r\n    throw new Error(\"Invalid arguments\");\r\n}\r\n\r\n\r\n/** Makes an array of listeners from the given listener map */\r\nfunction makeListenersFromMap(originStation: Emitter, isMatching: boolean, listenerMap: CallbackMap, context: any): Listener[] {\r\n\r\n    const listeners: Listener[] = [];\r\n\r\n    for (let eventName in listenerMap) {\r\n\r\n        listeners.push({\r\n            eventName: eventName,\r\n            callback: listenerMap[eventName],\r\n            context: !isMatching && context === undefined ? originStation : context,\r\n            matchCallback: listenerMap[eventName],\r\n            matchContext: context,\r\n        });\r\n    }\r\n\r\n    return listeners;\r\n}\r\n\r\n/** Makes an array of listeners from the given event name array */\r\nfunction makeListenersFromArray(originStation: Emitter, isMatching: boolean, eventNames: string[], callback: Function, context: any): Listener[] {\r\n\r\n    const listeners: Listener[] = [];\r\n\r\n    for (let i = 0, l = eventNames.length; i < l; i++) {\r\n\r\n        listeners.push({\r\n            eventName: eventNames[i],\r\n            callback: callback,\r\n            context: !isMatching && context === undefined ? originStation : context,\r\n            matchContext: context,\r\n            matchCallback: callback,\r\n        });\r\n    }\r\n\r\n    return listeners;\r\n}\r\n\r\nfunction emitEvent<P extends Promise<any>>(eventName: string, originStation: Emitter, enableAsync: boolean, args: any[]): P[] {\r\n\r\n    const stationMeta = originStation.stationMeta;\r\n    const listenersMap = stationMeta.listenersMap;\r\n\r\n    var listeners: Listener[];\r\n\r\n    if (stationMeta.enableRegExp) {\r\n        listeners = searchListeners(eventName, listenersMap, stationMeta.regExpMarker);\r\n    } else {\r\n        listeners = listenersMap[eventName];\r\n    }\r\n\r\n    var promises: P[] = [];\r\n\r\n    if (listeners) {\r\n\r\n        let result = applyListeners<P>(listeners, originStation, enableAsync, args);\r\n\r\n        if (enableAsync && result) {\r\n            promises = promises.concat(result);\r\n        }\r\n    }\r\n\r\n    const listenersMapAll = listenersMap['all'];\r\n\r\n    if (stationMeta.emitAllEvent && listenersMapAll) {\r\n\r\n        let argsAll = args.slice();\r\n\r\n        argsAll.splice(0, 0, eventName);\r\n\r\n        let result = applyListeners<P>(listenersMapAll, originStation, enableAsync, argsAll);\r\n\r\n        if (enableAsync && result) {\r\n            promises = promises.concat(result);\r\n        }\r\n    }\r\n\r\n    return promises;\r\n}\r\n\r\n/**\r\n * Retrieves listeners from the given listener map\r\n * that match the given event name. Specifically,\r\n * this function recognizes regular expression listeners.\r\n */\r\nfunction searchListeners(eventName: string, listenersMap: ListenersMap, regExpMarker: string): Listener[] {\r\n\r\n    var listeners: Listener[] = [];\r\n\r\n    for (let expression in listenersMap) {\r\n\r\n        if (expression.indexOf(regExpMarker) === 0) {\r\n\r\n            if (new RegExp(expression.substr(regExpMarker.length)).test(eventName)) {\r\n                listeners = listeners.concat(listenersMap[expression]);\r\n            }\r\n\r\n        } else if (expression === eventName) {\r\n\r\n            listeners = listeners.concat(listenersMap[eventName]);\r\n        }\r\n    }\r\n\r\n    return listeners;\r\n}\r\n\r\n/** Clean the `heardStations` property of the meta of the given station */\r\nfunction cleanHeardStations(station: EventStation): void {\r\n\r\n    const stationMap: StationMap = Object.create(null);\r\n    const heardStations = station.stationMeta.heardStations;\r\n\r\n    for (let stationId in heardStations) {\r\n\r\n        const heardStation = heardStations[stationId];\r\n\r\n        if (hasListener(heardStation.stationMeta, { hearer: station })) {\r\n            stationMap[stationId] = heardStation;\r\n        }\r\n    }\r\n\r\n    station.stationMeta.heardStations = stationMap;\r\n}\r\n\r\n/** Removes all listeners from then given station meta */\r\nfunction removeAllListeners(stationMeta: Meta): void {\r\n\r\n    const listenersMap = stationMeta.listenersMap;\r\n\r\n    for (let eventName in listenersMap) {\r\n\r\n        const listeners = listenersMap[eventName];\r\n\r\n        for (let listener of listeners) {\r\n            const hearer = listener.hearer;\r\n\r\n            if (hearer) {\r\n                hearer.stationMeta.hearingCount--;\r\n            }\r\n        }\r\n    }\r\n\r\n    stationMeta.listenerCount = 0;\r\n    stationMeta.listenersMap = Object.create(null);\r\n}\r\n\r\n/** Removes all listeners for a particular event from the given station meta */\r\nfunction removeListeners(eventName: string, stationMeta: Meta): void {\r\n\r\n    const listenersMap = stationMeta.listenersMap;\r\n    const listeners = listenersMap[eventName];\r\n\r\n    if (listeners === undefined) return;\r\n\r\n    const count = listeners.length;\r\n\r\n    for (let i = 0; i < count; i++) {\r\n\r\n        const listener = listeners[i];\r\n        const hearer = listener.hearer;\r\n\r\n        if (hearer) {\r\n            hearer.stationMeta.hearingCount--;\r\n        }\r\n    }\r\n\r\n    stationMeta.listenerCount = stationMeta.listenerCount - count;\r\n    delete listenersMap[eventName];\r\n}\r\n\r\n/**\r\n * Retrieves the targeted stations from the given parameters\r\n * This function normalizes the the target station for\r\n * cross-emitter listening methods.\r\n */\r\nfunction getTargetedStations(stationMeta: Meta, target?: EventStation | EventStation[]): EventStation[] {\r\n\r\n    if (target === undefined) {\r\n        return getHeardStations(stationMeta);\r\n    }\r\n\r\n    if (Array.isArray(target)) {\r\n        return <EventStation[]>target;\r\n    }\r\n\r\n    if ((<EventStation>target).stationMeta) {\r\n        return [<EventStation>target];\r\n    }\r\n\r\n    throw new Error(\"Invalid target\");\r\n}\r\n\r\n/**\r\n * @returns the heard stations of a given station's meta as an array\r\n */\r\nfunction getHeardStations(stationMeta: Meta): EventStation[] {\r\n\r\n    const stations: EventStation[] = [];\r\n    const heardStations = stationMeta.heardStations;\r\n\r\n    for (let stationId in heardStations) {\r\n        stations.push(heardStations[stationId]);\r\n    }\r\n\r\n    return stations;\r\n}\r\n\r\n/**\r\n * A literal object with non-delimited event names\r\n * as keys and callback functions as values.\r\n */\r\nexport interface CallbackMap {\r\n    [eventName: string]: Function;\r\n}\r\n"],"names":["injection.deps","injection.inject","options.config","options.reset","injection.reset","options.mergeOptions","options.globalOptions","options.assertOptions"],"mappings":"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"}